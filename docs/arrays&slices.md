## Arrays 

ë¯¸ë¦¬ ë§í•˜ìë©´ Goì—ì„œëŠ” Arraysë¥¼ ì˜ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ. ì˜ì•„í•˜ê² ì§€ë§Œ **Arrays** ë§ê³  **Slices** ì‚¬ìš©ì„ Goì—ì„œë„ ê¶Œì¥í•¨

ë°°ì—´ì€ ì§€ì •ëœ í˜•ì‹ì˜ ë©”ëª¨ë¦¬ë¥¼ ë§Œë“¤ ë•Œ ìœ ìš©í•˜ë©° í• ë‹¹ì„ í”¼í•˜ëŠ” ë° ë„ì›€ì´ ë  ìˆ˜ ìˆì§€ë§Œ, ì£¼ë¡œ Slices(ì•„ë˜ 8ë²ˆì§¸ ì„¹ì…˜)ì„ êµ¬ì„±í•˜ëŠ” Blockìœ¼ë¡œ ì‚¬ìš© ë¨. 



``` go
var nums [5]int
days := [3]string{"a", "b", "c"}
var temps [5]float64 = [5]float64{24.3, 26.1}
```



**ì„ ì–¸ ê°œìˆ˜ëŠ” í•­ìƒ ìƒìˆ˜**

``` go
const x = 5
y := 3

[x]int{1, 2, 3, 4, 5} // OK
[y]int{1, 2, 3}				// ERROR
```



**index ì§€ì • ì´ˆê¸°í™”**

``` go
var s = [5]int{1:10, 3:30}  // [0 10 0 30 0]
```



**ë°ì´í„° í¬ê¸°ì— ë”°ë¼ ì´ˆê¸°í™”**

``` go
x := [...]int{10, 20, 30}  // [10 20 30]
```

`[...]int{10, 20, 30}` ì™€ ` []int{10, 20, 30}` ëŠ” ì•„ì˜ˆ ë‹¤ë¦„

ì „ìëŠ” ì •ì  ë°°ì—´ <small>Arrays</small> ì´ê³ , í›„ìëŠ” ë™ì  ë°°ì—´ <small>Slices</small> ì„



### ë°°ì—´ ìˆœíšŒ

``` go
nums := [...]int{10, 20, 30, 40, 50}
nums[2] = 300

// í¬ê¸° ê¸°ì¤€
for i := 0; i < len(nums); i++ {
  print(nums[i])
}

// range keyword - i: index, v: value
var t [5]float64 = [5]float64{24.0, 25.9, 26.4, 23.5, 29.3}
for i, v := range t {
  print(i, v)
}
```



**ë°°ì—´ì€ ì—°ì†ëœ ë©”ëª¨ë¦¬**

Typeì€ ë©”ëª¨ë¦¬ì˜ í¬ê¸°

ìš”ì†Œ ìœ„ì¹˜ = ë°°ì—´ ì‹œì‘ ì£¼ì†Œ + (ì¸ë±ìŠ¤ x íƒ€ì…í¬ê¸°)



### Go Arrays VS C Array s

âœ”ï¸ Goì—ì„œ ë°°ì—´ì€ **ê°’** ğŸ‘‰ğŸ» í•˜ë‚˜ì˜ Arraysë¥¼ ë‹¤ë¥¸ Arraysì— í• ë‹¹í•˜ë©´ **ëª¨ë“  ìš”ì†Œê°€ ë³µì‚¬**ëœë‹¤.

âœ”ï¸ íŠ¹íˆ, ë°°ì—´ì„ í•¨ìˆ˜ì— ì „ë‹¬í•˜ë©´ í•´ë‹¹ í•¨ìˆ˜ì— ëŒ€í•œ **í¬ì¸í„°ê°€ ì•„ë‹ˆë¼ ë°°ì—´ì˜ ë³µì‚¬ë³¸**ì„ ë°›ê²Œ ë˜ë‹ˆ ì£¼ì˜

âœ”ï¸ë°°ì—´ì˜ í¬ê¸°ëŠ” ë°°ì—´ íƒ€ì…ì˜ ì¼ë¶€ ğŸ‘‰ğŸ» `[10]int`ì™€ `[20]int` ìœ í˜•ì€ ì„œë¡œ ë‹¤ë¦„.



**Value**ë¡œ ì „ë‹¬ë˜ëŠ” ê±´ ìœ ìš©í•  ìˆ˜ë„ ìˆì§€ë§Œ ë¹„ìš©ì´ ë§ì´ ë“¤ ìˆ˜ë„ ìˆìŒ. 

ë§Œì•½ íš¨ìœ¨ì„±ì„ ë†’ì´ê¸° ìœ„í•´ Cì˜ ë°°ì—´ì²˜ëŸ¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ í¬ì¸í„°ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŒ.  ğŸ‘‰ğŸ» ê·¼ë° ë¹„ì¶”. Slices ì°¸ê³ 

```
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```





## Slices

ìŠ¬ë¼ì´ìŠ¤ëŠ” ë°°ì—´ì„ ë˜í•‘í•˜ì—¬ Data sequencesì— ë³´í¸ì ì´ê³  ê°•ë ¥í•˜ë©° í¸ë¦¬í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µ. 

Goì—ì„œëŠ” Arrayë¥¼ íŠ¹ì • ê²½ìš°(ë³€í™˜ í–‰ë ¬ê³¼ ê°™ì´ ê·œê²©ì´ í•„ìš”í•œ ê²½ìš°...)ë¥¼ ì œì™¸í•˜ê³  ëŒ€ë¶€ë¶„ Slicesë¥¼ ì‚¬ìš©.



ìŠ¬ë¼ì´ìŠ¤ëŠ” ê¸°ë³¸ ë°°ì—´ì— ëŒ€í•œ ì°¸ì¡°ê°’ì„ ë³´ê´€.

í•œ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë‹¤ë¥¸ ìŠ¬ë¼ì´ìŠ¤ì— í• ë‹¹í•˜ëŠ” ê²½ìš° ë‘˜ ë‹¤ ë™ì¼í•œ ë°°ì—´ì„ ë‚˜íƒ€ë‚¸ë‹¤.



ë™ì  ë°°ì—´? ì •í™•íˆëŠ” **ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°**.

<img src="./image/ìŠ¬ë¼ì´ìŠ¤êµ¬ì„±2.png" alt="img" style="zoom:38%;" />



### Slicesì˜ ë™ì‘ì›ë¦¬

``` go
type SliceHeader struce {
  Data uintptr		// ì‹¤ì œ ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
  Len int					// ìš”ì†Œ ê°œìˆ˜
  Cap int					// capacity. ì‹¤ì œ ë°°ì—´ì˜ ê¸¸ì´. ìµœëŒ€ ìš©ëŸ‰ì„ ë‚˜íƒ€ëƒ„.
}
```



**len() & cap()**

`len(s)` : slices ì˜ ê¸¸ì´

`cap(s)` : slices ì˜ ìš©ëŸ‰

ìš©ëŸ‰ì€ ì•„ë˜ì—ì„œ ìì„¸íˆ í™•ì¸!



ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„° + sliceì˜ ê¸¸ì´ + sliceì˜ ìš©ëŸ‰

<img src="./image/ìŠ¬ë¼ì´ìŠ¤êµ¬ì„±ìš”ì†Œ.png" alt="img" style="zoom:48%;" />





### ì´ˆê¸°í™”

``` go
slice := []int{1, 2, 3}

if len(slice) == 0 {
  print("slice is empty", slice)
}

slice := []int
slice[1] = 10 // ERROR í¬ê¸°ê°€ 0ì¸ë° 1ì— ì ‘ê·¼
```



#### index ì§€ì •

``` go
slice := []int{1: 30, 3:20, 6:10}	// [0 30 0 20 0 0 10]
```



#### make([]T, len, cap)

***func make([]T, len, cap) []T***



``` go
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:] // len(b)=4, cap(b)=4
```





### ìš”ì†Œ ì¶”ê°€

#### append([]T, ...T) â­ï¸

***func append(s []T, x ...T) []T***



``` go
s = append(s, 3, 12)		// ìƒˆë¡œìš´ sliceë¥¼ ìƒì„±í•´ì„œ ë„˜ê¹€
s1 = append(s1, s2...)
```

ê¸°ì¡´ ìŠ¬ë¼ì´ìŠ¤ê°€ ë°”ë€” ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆìŒ. 

â­ï¸ **cap** ì— ë”°ë¼ ë‹¬ë¼ì§



**ë¹ˆ ê³µê°„ì´ ì¶©ë¶„í•œê°€?**

YES : ë¹ˆ ê³µê°„ì— ìš”ì†Œ ì¶”ê°€

NO : ìƒˆë¡œìš´ ë°°ì—´ í• ë‹¹ â†’ ë³µì‚¬ â†’ ìš”ì†Œ ì¶”ê°€



``` go
s := make([]int, 0, 3)
for i := 0; i < 5; i++ {
    s = append(s, i)
    fmt.Printf("cap %v, len %v, %p\n", cap(s), len(s), s)
}

/* result
cap 3, len 1, 0x1040e130
cap 3, len 2, 0x1040e130
cap 3, len 3, 0x1040e130
cap 6, len 4, 0x10432220
cap 6, len 5, 0x10432220
*/
```



**â­ï¸ append() ì˜ return -> ê¸°ì¡´ ë°°ì—´ or ìƒˆë¡œìš´ ë°°ì—´**

``` go
package main

import (
    "fmt"
)

func main() {

	s := make([]int, 0, 3)
	s = append(s, 10, 20)

	s1 := append(s, 30)
	s2 := append(s, 30, 40)

	PrintSlice(s)
	PrintSlice(s1)
	PrintSlice(s2)
}

func PrintSlice (s []int) {
	fmt.Printf("%v, cap %v, len %v, %p\n", s, cap(s), len(s), s)
}

/*
[10 20]      , cap 3, len 2, 0xc0000b4000
[10 20 30]   , cap 3, len 3, 0xc0000b4000
[10 20 30 40], cap 6, len 4, 0xc0000aa090

s ëŠ” s1ì€ ë™ì¼ (capë³´ë‹¤ ì‘ê¸° ë•Œë¬¸ì— ê¸°ì¡´ì˜ ë°°ì—´ì— ì¶”ê°€)
s ëŠ” s2ì€ ë‹¤ë¦„ (capë³´ë‹¤ ì»¤ì§€ê¸° ë•Œë¬¸ì— ìƒˆë¡œìš´ ë°°ì—´ ìƒì„±) 
*/
```



**â­ï¸ append() ì˜ return -> ê¸°ì¡´ ë°°ì—´ or ìƒˆë¡œìš´ ë°°ì—´ - í•¨ìˆ˜**

``` go
func addNum(slice []int) {
  slice = append(slice, 4)
}

func addNumPtr(slice *[]int) {
  *slice = append(*slice, 4)
}

func addNumReturn(slice []int) []int {
  slice = append(slice, 4)
  return slice
}

func main() {
  slice := []int{1, 2, 3}			// len(3), cap(3)
  addNum(slice)								// sliceëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŒ

  addNumPtr(&slice)				  	// slice ë³€ê²½í•˜ëŠ” ë°©ë²• 1
  slice = addNumReturn(slice)	// slice ë³€ê²½í•˜ëŠ” ë°©ë²• 2
  
  fmt.PrintLn(slice)
}
```





#### ê¸°ì¡´ ë°°ì—´ì„ ì´ìš©í•œ ìƒˆë¡œìš´ ë°°ì—´

``` go
s := []int{1, 2, 3, 4, 5}

// 1. ê°€ë³€ì¸ìë¥¼ ì‚¬ìš© (ì²˜ìŒì—” ê°€ë…ì„± ë–¨ì–´ì§)
s1 := append([]int{}, s...)

// 2. make-copyë¥¼ ì‚¬ìš© (ê¸¸ì§€ë§Œ ëª©ì ì´ ë¶„ëª…í•˜ê²Œ ë³´ì„)
s2 := make([]int, len(s))
copy(s2, s)

// 3. forë¬¸ìœ¼ë¡œ ëŒ€ì… (ê¸¸ì–´)
s2 := make([]int, len(s))
for i , v := range s {
  s2[i] = v
}
```





### ìŠ¬ë¼ì´ì‹±

**â­ï¸ Slicesì˜ ìŠ¬ë¼ì´ì‹±ì€ ë³µì‚¬ê°€ ì•„ë‹ˆë¼ ì°¸ì¡°**

``` go
arr := []int{1, 2, 3, 4, 5}
sc := arr[1:2]					// scëŠ” [2]

// slicingìœ¼ë¡œ ë§Œë“¤ë©´ referenceê°’ìœ¼ë¡œ ì„œë¡œì˜ ê°’ì„ ë³€ê²½í•˜ê²Œ ë¨
arr[1] = 100						// scëŠ” [100]
sc = append(sc, 500)	// arrëŠ” [1 100 500 4 5]
```



**sliceë¥¼ ìŠ¬ë¼ì´ì‹±ì„ í•  ë•Œì—ëŠ” ê¸°ì¡´ì˜ Arraysì˜ í¬ê¸°ë¥¼ ë³¸ë‹¤.**

``` go
arr := []int{1, 2, 3, 4, 5}
sc := arr[1:10]
sc2 := sc[2:99] 		// scëŠ” 10ê¹Œì§€ë§Œ slicingí–ˆì§€ë§Œ ì›ë˜ ë°°ì—´ì˜ í¬ê¸°ë¥¼ ë³´ê¸°ë•Œë¬¸ì— ì—ëŸ¬ê°€ ë‚˜ì§€ ì•ŠìŒ.
```





### ìš”ì†Œ ì‚­ì œ

``` go
slice = append(slice[:idx], slice[idx+1:]...)
```



### ìš”ì†Œ ì¶”ê°€

``` go
slice = append(slice[:idx], append([]int, slice[idx:]...)...)
```

ì¤‘ê°„ì— ë©”ëª¨ë¦¬ í•œ ë²ˆ ë” ì”€.



``` go
slice = append(slice, 0)		// ë§¨ ë’¤ì— ìš”ì†Œ ì¶”ê°€ (len ë§ì¶”ê¸° ~)
copy(slice[idx+1:], slice[idx:]) // ê°’ ë³µì‚¬
slice[idx] = 100						// ê°’ ë³€ê²½
```



### ìš”ì†Œ ì •ë ¬

``` go
slice := []int{5, 2, 4, 7, 1}
sort.Ints(slice)
```


